def calculate_add_or_multiply(n):
    """How to double and add to n from 1, returned as a list of * and +"""
    op_list = []
    while n != 1:
        if n % 2 == 0:
            op_list.append('*')
            n = n / 2
        else:
            op_list.append('+')
            n -= 1
    return reversed(op_list)

def perform_operations(U, V, P, Q, D, n, op_list):
    """Calculates U and V values for the index generated by op_list"""
    k = 1

    for operation in op_list:
        if operation == '*':
            U, V = U*V, V**2 - 2*(Q**k)
            k *= 2
        else:
            k += 1
            if (P*U + V) % 2 == 0:
                if (D*U + P*V) % 2 == 0:
                    U, V = (P*U + V)/2, (D*U + P*V)/2
                else:
                    U, V = (P*U + V)/2, (D*U + P*V + n)/2
            elif (D*U + P*V) % 2 == 0:
                U, V = (P*U + V + n)/2, (D*U + P*V)/2
            else:
                U, V = (P*U + V + n)/2, (D*U + P*V + n)/2
    return U, V

def lucas_pp(n, D, P, Q):                                                                                                                                                                                                                         
    """Perform the Lucas probable prime test"""
    U, V = perform_operations(1, P, P, Q, D, n, calculate_add_or_multiply(n+1))

    if U % n != 0:
        return False # Failed the weaker probable prime test

    d = n + 1
    s = 0
    while d % 2 == 0:
        d = d/2
        s += 1

    U, V = perform_operations(1, P, P, Q, D, n, calculate_add_or_multiply(d))

    if U % n == 0:
        return True # A strong probable prime

    for r in xrange(s):
        U, V = perform_operations(1, P, P, Q, D, n, calculate_add_or_multiply(d*(2**r)))
        if V % n == 0:
            return True

    return False